#!/usr/bin/python

import sys
import feedparser
import urllib2
from bs4 import BeautifulSoup
import mailer
import cPickle as pickle #pickle rather than plaintext config files for various reasons, mostly future extensibility and not having to parse things by hand.


feed = feedparser.parse('https://nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-Recent.xml')

flagwords = ['windows','osx','redhat','openssl'] #look, this can be anything. If you're serious about these, maintain a list of relevant CPEs.
#because this is a quick and dirty hack for fun

#this is where we're looking for exploits.
edb_url = 'http://www.exploit-db.com/search/?action=search&filter_cve=%s'
meta_url = 'http://www.rapid7.com/db/search?q=%s&t=m'

entries = feed['entries'] #feed per se is unweildy as heck

cves = {} #here's where we'll store relevant (for given relevant) CVEs

#testing CVEs, put them in if you want.
#cves['2014-4872'] = {'reason':'testing porpoises','vuln_summary':'Numara Track-it! something something'}
#cves['2014-4877'] = {'reason':'testing porpoises too','vuln_summary':'gnu_wget symlink access'}



dump_file_name = '%s_dump' % sys.argv[0] #we use this to store a timestamp. This is dumb. Too bad.

try:
	timestamp = pickle.load(open(dump_file_name,'r'))
except IOError:
	timestamp = '2014-10-27T09:34:38.913-04:00'

max_timestamp = timestamp[:] #new shallow copy not reference, for reasons like these should be distinct objects.


def add_cve(flagged,cveblob,text=None):
""" it seemed to make sense to make this a method """
	#not that there's a class for it to be a method of, right now.
	global cves
	if flagged:
		if text:
			cveblob['reason'] = text
		cves[cveblob['vuln_cve-id'][4:]] = cveblob #it is probably not necessary to strip CVE- from the beginning of these strings.
	return flagged


for k in entries: #k, here, is a dict of parsed xml junk from feedparser.
	flagged = 0
	d = {} #local storage

	#check and update timestamp
	try: #lotta tries in this, because: RSS is rubbish and lots of things are missing fields.
		vulntime =  k['vuln_last-modified-datetime']
	except KeyError:
		try:
			vulntime = k['vuln_published-datetime']
		except KeyError:
			vulntime = None

	if vulntime:
		if vulntime > timestamp:
			if vulntime > max_timestamp:
				max_timestamp = vulntime
		else:
			continue #skip old records


	try:
		d['cvss_score'] = float(k['cvss_score']) #do not forget to cast this because otherwise float<>string comparisons will make you sad
		if d['cvss_score'] >= 8.0:
			flagged = 1
	except KeyError:
		pass

	if add_cve(flagged,k,'severity of CVE'):
		continue

	try:
		d['vuln_soft'] = k['vuln_vulnerable-software-list'].lower() #often empty
		for word in flagwords:
			if word in d['vuln_soft']:
				flagged = 1
				continue
	except KeyError:
		pass

	if add_cve(flagged,k,' relevant software'):
		continue

	try:
		d['vuln_product'] = k['vuln_product'].lower() #use cpes if you have them, here. but parsing that list for interesting things is boring.
		for word in flagwords:
			if word in d['vuln_product']:
				flagged = 1
				continue
	except KeyError:
		pass

	if add_cve(flagged,k, ' relevant software'):
		continue

	try:
		d['cpe_lang'] = k['cpe-lang_fact-ref']['name'].lower()
		for word in flagwords:
			if word in d['vuln_soft']:
				flagged = 1
				continue
	except KeyError:
		pass

	if add_cve(flagged,k, ' relevant software'):
		continue

	try:
		d['vuln_summary'] = k['vuln_summary'].lower()
		for word in flagwords:
			if word in d['vuln_soft']:
				flagged = 1
				continue
	except KeyError:
		pass

	if add_cve(flagged,k,'keyword match in summary - may not be important'): #obviously, if you're running CPE checks not random strings, they might be more important. Or not!
		continue


timestamp = max_timestamp

pickle.dump(timestamp,open(dump_file_name,'w')) #save this one for later!


message = '' # you don't have to do this. you can just print everything. But because I want to email it, I'm storing it all.


for k in cves.keys():

	cve_blob = {}
	cve_blob['cveid'] = 'CVE-%s' % k
	cve_blob['edb_url'] = edb_url % k
	cve_blob['edb'] = []
	cve_blob['meta_url'] = meta_url % k
	cve_blob['meta'] = []

	req = urllib2.urlopen(edb_url % k)
	soup = BeautifulSoup(req.read())
	if len(soup.find_all('td','list_explot_dlink')) > 0: #there's a exploit on exploitdb
		cve_blob['edb'] = []
		for x in soup.select("td.list_explot_dlink a"): #do not ask why this is a different selector to the if condition.
			cve_blob['edb'].append(x['href'])

	req = urllib2.urlopen(cve_blob['meta_url'])
	soup = BeautifulSoup(req.read())
	x = soup.select("section.vbresultList article.vbResultItem a")
	if req.url != cve_blob['meta_url'] or len(x) >= 1: #rapid7 will direct you to the exploit page if there is only one.
		#search results will be displayed if there are 0 or 2+
		cve_blob['meta'] = []
		if req.url != cve_blob['meta_url']:
			cve_blob['meta'].append(req.url)
		else:
			for line in x:
				cve_blob['meta'].append('http://www.rapid7.com/%s' %line['href']) #why would you use relative links? This will break if they up their game.
	
	if len(cve_blob['edb']) > 0 or len(cve_blob['meta']) > 0: #got exploits
		try:
			severity = cves[k]['cvss_score'] #like I said, sometimes things go missing
		except KeyError:
			severity = '?'
		
		message += '%s severity:%s\n' % (cve_blob['cveid'], severity)
		message += 'flagged for %s\n\n' % cves[k]['reason']
		#print cves[k].keys()
		message += '%s\n' % cves[k]['vuln_summary']
		if len(cve_blob['edb']) > 0:
			message += "Exploit Database links:\n"
			for x in cve_blob['edb']:
				message += "\t%s\n" % x
		if len(cve_blob['meta']) > 0:
			message += "Metasplot Exploit modules:\n"
			for x in cve_blob['meta']:
				message += "\t%s\n" % x

		message += "\n\n"

if message != '':
	mailer.send_email('your@email','CVEs with exploits report', message)

#print message #if you are looking live, hey?